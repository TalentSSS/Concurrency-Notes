## 第3章 对象的共享

关键字synchronized不仅能用于实现原子性或者确定“临界区”，还有另一个重要方面：内存可见性（Memory Visibility）。即不仅**要防止某个线程正在使用对象状态而另一个线程在同时修改该状态**，而且要**确保当一个线程修改了对象状态后，其他线程要能够看到发生的状态变化**。

### 3.1 可见性

通常无法确保执行读操作的线程能适时地看到其他线程写入的值。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

在没有同步的情况下，**编译器、处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整**。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

#### 3.1.1 失效数据

除非每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：**一个线程可能获得某个变量的最新值，而获得另一个变量的失效值**。

#### 3.1.2 非原子的64位操作

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证被称为**最低安全性**。

最低安全性适用于绝大多数变量，但存在例外：**非volatile类型的64位数值变量**。

Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，**JVM允许将64为的读操作或写操作分解为两个32位操作**。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，**在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的**，除非用关键字volatile来声明它们，或者用锁保护起来。

#### 3.1.3 加锁与可见性

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。即当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在**锁被释放之前，A看到的变量值在B获得锁后同样可以由B看到**。

在访问某个共享且可变的变量时，要求所有线程在同一个锁上同步，是为了确保某个线程写入该变量对于其他线程来说都是可见的。

**加锁的含义不仅仅局限于互斥行为，还包括内存可见性**。为了确保所有线程都能看到共享变量最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

#### 3.1.4 Volatile变量

Java提供了volatile变量来确保变量的更新操作通知到了其他线程。

当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量时共享的，因此不会将该变量上的操作与其他内存操作一起重排序，volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方。

访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。

从内存可见性的角度看，**写入**volatile变量相当于**退出同步代码块**，而**读取**volatile变量相当于**进入同步代码块**。

在代码中依赖volatile变量来控制可见性，通常比使用锁的代码更脆弱，也更难以理解。

**仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们**。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。**volatile变量的正确使用方式：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期时间的发生**（例如，初始化或关闭）。

volatile变量的一种典型用法

```java
volatile boolean asleep;
...
    while (!asleep)
        countSomeSheep();
```

volatile变量**通常用做某个操作完成、发生中断或状态的标志**。volatile的语义不足以确保递增操作(count++)的原子性，除非能确保只有一个线程对变量执行写操作。

**加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。**

当且仅当满足以下所有条件时，才应该使用volatile变量：

* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单线程更新变量的值
* 该变量不会与其他状态变量一起纳入不变性条件中
* 在访问变量时不需要加锁

### 3.2 发布与逸出

“发布”一个对象是指，使对象能够在当前作用域之外的代码中使用。例如将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个**非私有的方法中返回该引用**。

将对象的引用保存到一个公有的静态变量中

```java
public static Set<Secret> knownSecrets;
public void initialize() {
    knowSecrets = new HashSet<Secret>();
}
```

从非私有方法中返回一个引用

```java
class UnsafeStates {
    private String[] states = new String[] {
        "AK", "AL", ...
    };
    public String[] getStates() { return states; }
}
```

states这个变量逸出了作用域。

当发布某个对象时，可能会间接地发布其他对象。

当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。

无论其他线程会对已发布的引用执行何种操作，**误用该引用的风险都始终存在**。某个对象**逸出后**，必须假设有某个类或线程可能会误用该对象。这正是需要**封装**的主要原因：封装能够使对程序的**正确性进行分析变得可能**，并使得无意中**破坏约束条件变得更难**。

发布一个内部的类实例也是一种发布对象或内部状态的机制。这里的内部类会自动持有外部类的引用，使得ThisEscape在没有被构造完成的情况下就逸出了this指针

```java
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            });
    }
}
```

#### 安全的对象构造过程

如果this引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。

**一个常见的错误：在构造函数中启动一个线程。**

当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。即**在对象尚未完全构造之前，新的线程就可以看见它**。

在构造函数中可以创建线程，但不要立即启动线程，而是通过一个start或initialize方法启动。

用**工厂方法**来防止this引用在构造过程中逸出

```java
public class SafeListener {
    private final EvenListener listener;
    private SafeListener() {
        public void onEvent(Event e) {
            doSomething(e);
        }
    }
    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
```

### 3.3 线程封闭

当某个对象**封闭在一个线程中**时，这种用法将**自动实现线程安全性**，及时被封闭的对象本身不是线程安全的。

Java语言及其核心库提供了一些机制来帮助维持线程封闭性，如局部变量和ThreadLocal类，但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。

#### 3.3.1 Ad-hoc线程封闭

Ad-hoc线程封闭指维护线程封闭性的职责完全由程序实现来承担。

这种方式非常脆弱，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。

在程序上尽量少用，可能的情况下尽量采用更强的线程封闭技术（栈封闭或ThreadLocal类）。

#### 3.3.2 栈封闭

栈封闭是线程封闭的一种特例，在栈封闭中，只有**通过局部变量才能访问对象**。

**局部变量的固有属性之一就是封闭在执行线程中**。它们位于执行线程的栈中，其他线程无法访问这个栈。

栈封闭比Ad-hoc线程封闭更易于维护，也更加健壮。

```java
public int loadTheArk(Collection<Animal> candidates) {
    SortedSet<Animal> animals;
    int numPairs = 0;
    Animal candidate = null;
    
    // animals被封闭在方法中，不要使它们溢出
    animals = new TreeSet<Animal>(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for (Animal a : animals) {
        if (candidate == null || candidate.isPotentialMate(a))
            candidate = a;
        else {
            ark.load(new AnimalPair(candidate, a));
            ++numPairs;
            candidate = null;
        }
    }
    return numPairs;
}
```

animals引用指向集合animals，这个引用被封闭在局部变量中，因此也被封闭在执行线程中。

在线程的上下文使用类似的非线程安全的对象，该对象仍然是线程安全的。

#### 3.3.3 ThreadLocal类

维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。

ThreadLocal提供了get与set等访问接口或方法，这些方法**为每个使用该变量的线程都存有一份独立的副本**，因此get总是**返回由当前执行线程在调用set时设置的最新值**。

ThreadLocal对象通常用于防止对可变的单实例（Singleton）或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个而方法都要传递一个Connection对象

```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
  	public Connection initialValue() {
        return DriverManager.getConnection(DB_URL);
    };
}
public static Connection getConnection() {
    return connectionHolder.get();
}
```

### 3.4 不变性

如果某个对象在**被创建后其状态就不能被修改**，那么这个对象那个就称为**不可变对象**。

线程安全性是不可变对象的固有属性之一，它们的**不变性条件是由构造函数创建的**，只要它们的状态不改变，这些不变性条件就能得以维持。

**不可变对象一定是线程安全的。**

不可变性**并不等于将对象中所有的域都声明为final类型**，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为**在final类型的域中可以保存对可变对象的引用**。

当满足以下条件时，对象才是不可变的

* 对象创建以后其状态不能修改
* 对象的所有域都是final类型
* 对象是正确创建的（在对象创建期间，this引用没有逸出）

在不可变对象的内部仍可以使用可变对象来管理它们的状态

```java
public final class ThreeStorages {
  	private final Set<String> storages = new HashSet<String>();
  	
  	public ThreeStorages() {
    		storages.add("Moe");
      	storages.add("Larry");
      	storages.add("Curly");
	  }
  
  public boolean isStorage(String name) {
    	return storages.contains(name);
  }
}
```

#### 3.4.1 Final域

final类型的域是**不能修改**的(但**如果fianl域所引用的对象是可变的，那么这些被引用的对象是可以修改的**)。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

即使对象可变，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。

"**除非需要某个域是可变的，否则应将其声明为final域**"，是一个良好的编程习惯。

#### 3.4.2 使用volatile类型来发布不可变对象

用**volatile类型和不可变对象**可以提供一种弱形式的原子性。

对于在访问和更新多个相关变量时出现的竞态条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。如果是一个**可变的对象**，那么就**必须使用锁来确保原子性**。如果是一个不可变对象，那么当线程获得了该对象的引用后，就不用担心另一个线程会修改对象的状态。如果要更新这些变量，那么可以**创建一个新的容器对象**，但其他使用原有对象的线程仍然会看到对象处于一致的状态。

通过**使用包含多个状态变量的容器对象来维持不变性条件**，并使用一个volatile类型的引用来确保可见性。

### 3.5 安全发布

某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。

#### 3.5.1 不正确发布：正确的对象被破坏

不能指望一个尚未被完全创建的对象拥有完整性。观察该对象的线程将看到对象处于不一致状态，看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。

```java
public class Holder {
    private int n;
    public Holder(int n) {this.n = n; }
    
    public void assertSanity() {
        if (n != n)
            throw new AssertionError("This statement is false.");
    }
}
```

**没有使用同步来确保Holder对象对其他线程可见**，因此将Holder称为"未被正确发布"。

存在两个问题。

首先，除发布对象的线程外，**其他线程可以看到Holder域是一个失效值**，因此将看到一个空引用或者之前的旧值。

然而，更糟糕的情况是，线程看到Holder引用的值是最新的，但Holder状态的值却是失效的。

更不可预测，在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值，这也是assertSainty抛出AssertionError的原因。

#### 3.5.2 不可变对象与初始化安全性

不可变对象是一种非常重要的对象，**Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证**。即使**某个对象的引用对其他线程是可见**的，也**并不意味着对象状态对于使用该对象的线程来说一定可见**。为了确保对象状态能呈现出一致的视图，就必须使用同步。

即使在发布不可变对象的引用时**没有用同步**，也**仍然可以安全地访问该对象**。为了维持这种初始化安全性的保证，必须**满足不可变性**的所有需求：**状态不可修改，所有域都是final类型，以及正确的构造过程**。

**任何线程都可以在不需要额外同步的情况下同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。**

这种保证还将延伸到被正确创建对象中所有final类型的域。在没有额外同步的情况下，也可以安全地访问final类型的域。但如果final域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。

#### 3.5.3 安全发布的常用模式

可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时必须使用同步。

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

* 在静态初始化函数中初始化一个对象引用
* 将对象的引用保存到volatile类型的域或AtomReference对象中
* 将对象的引用保存到某个正确构造对象的final类型域中
* 将对象的引用保存到一个由锁保护的域中

在线程安全容器内部同步意味着，在讲对象放入到某个容器中，如Vector或synchronizedList时，将满足最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便这段读/写X的应用程序代码中没有包含显式的同步。

线程安全库中的容器类提供了以下的安全发布保证

* 通过将**一个键或者值**放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程
* 通过将**某个元素**放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、sychronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程
* 通过将**某个元素**放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程

通常，要**发布一个静态构造的对象**，最简单和最安全的方式是使用**静态的初始化器**：

```java
public static Holder holder = new Holder(42);
```

**静态初始化器由JVM在类的初始化阶段执行**。由于在**JVM内部存在着同步机制**，因此通过这种方式初始化的任何对象都可以被安全地发布。

#### 3.5.4 事实不可变对象

如果对象在发布后不会被修改，那么对于其他没有额外同步情况下安全地访问这些对象的线程来说，安全发布是足够的。

如果对象**从技术上来看是可变的**，但其状态**在发布后不会再改变**，那么把这种对象称为"事实不可变对象"。

通过使用事实不可变对象，可以**简化开发过程**，而且还能由于**减少了同步而提高性能**。

**在没有额外的同步情况下，任何线程都可以安全地使用被安全发布的事实不可变对象**。

#### 3.5.5 可变对象

如果对象在**构造后可以修改**，那么**安全发布只能确保"发布当时"状态的可见性**。

对于**可变对象**，不仅在发布对象时需要使用同步，而且在每次对象**访问时同样需要使用同步**来确保后续修改操作的可见性。

要安全地共享可变对象，**这些对象就必须被安全地发布**，并且必须是线程安全的或由某个锁保护起来。

对象的发布需求取决于它的可变性：

* 不可变对象可以通过任意机制来发布
* 事实不可变对象必须通过安全方式来发布
* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来

#### 3.5.6 安全地共享对象

发布一个对象时，必须明确说明对象的访问方式。

在并发程序和共享对象时，可以使用一些使用的策略：

* **线程封闭**：线程封闭的对象只能由一个线程持有，对象被封闭在该线程中，并且只能由这个线程修改。
* **只读共享**：在没有额外同步的情况下，**共享的只读对象**可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括**不可见对象**和**事实不可变对象**。
* **线程安全共享**：线程安全的对象在其**内部实现同步**，因此多个线程可以**通过对象的公有接口**来进行访问而不需要进一步同步。
* **保护对象**：被保护的对象**只能通过持有特定的锁来访问**。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由**某个特定锁保护的对象**。

