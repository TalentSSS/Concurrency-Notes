# Java并发编程实战

## 第1章 简介

### 1.1 并发简史

在计算机中加入操作系统实现多个程序同时运行的原因：

* 资源利用率：程序在等待时能运行另一个程序
* 公平性：不同的用户和程序对计算机上的资源有同等的使用权（时间分片）
* 便利性：每个程序执行一个任务在必要时通信，比只写一个程序来计算所有任务更容易

线程允许在同一个进程中同时存在多个程序控制流，会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器(PC)、栈以及局部变量等。

### 1.2 线程的优势

#### 1.2.1 发挥多处理器的强大能力

如果设计正确，多线程程序可以通过提高处理器资源的利用率来提高系统吞吐率。

#### 1.2.2 建模简单

如果需要完成多种类型的任务，那么需要管理不同任务之间的优先级和执行时间，并在任务之间进行切换，将带来额外的开销。

通过线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。

#### 1.2.3 异步时间的简化处理

如果每个请求都拥有自己的处理线程，那么在处理某个请求时发生的阻塞将不会影响其他请求的处理。

#### 1.2.4 响应更灵敏的用户界面

如果在事件线程中执行的任务都是短暂的，那么界面的响应灵敏度就较高，因为事件线程能够很快地处理用户的动作。如果将长时间运行的任务放在一个单独的线程中运行，事件线程就能及时地处理界面事件，从而使用户界面具有更高的灵敏度。

### 1.3 线程带来的风险

#### 1.3.1 安全性问题

多线程之间的交替操作有可能导致不可预料的结果。如果错误地假设程序总的操作将按照某种特定顺序执行，会存在危险（**竞态条件**）。

要使多线程程序的行为可以预测，必须对共享变量的访问操作进行协同（**同步**），这样才不会在线程之间发生彼此干扰。

#### 1.3.2 活跃性问题

活跃性问题含义：某件正确的事情最终会发生。

死锁、饥饿、活锁。

#### 1.3.3 性能问题

多线程程序中，上下文切换、线程调度、同步机制共享数据，这些因素都会带来额外的性能开销。

### 1.4 线程无处不在

开发的程序中没线程，但框架中有线程，在这些线程中调代码同样必须是线程安全的。某个框架在应用程序中引入并发性时，通常不可能将并发性仅局限于框架代码。**框架通过在框架线程中调用应用程序代码将并发性引入到程序中，在代码中将不可避免地访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的。**

下面给出的模块都将在应用程序之外的线程中调用应用程序的代码

* Timer
* Servlet和JavaServer Page(JSP)
* 远程方法调用(Remote Method Invocation, RMI)，必须注意两个线程安全问题：正确地**协同在多个对象中共享的状态**，以及**对远程对象本身状态的访问**。
* Swing和AWT

## 第2章 线程安全性

在构建稳健的并发程序时，必须正确地使用**线程**和**锁**。要编写线程安全的代码，核心在于要对状态访问进行管理，特别是对**共享**的（Shared）和**可变**的（Mutable）状态的访问。

“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

* 不在线程之间共享该状态变量
* 将状态变量修改为不可变的变量
* 在访问状态变量时使用同步

当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不可变性规范都能起到一定的帮助作用。

### 2.1 什么是线程安全性

线程安全的定义中，最核心的概念就是**正确性**。

正确性的含义是：某个类的**行为**与其**规范**完全**一致**。

**线程安全性**：当多个线程访问某个类时，**不管运行时环境采用何种调度方式**或者**这些线程将如何交替执行**，并且在**主调代码中不需要任何额外的同步或协同**，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

**无状态的对象一定是线程安全的**。

### 2.2. 原子性

#### 2.2.1 竞态条件

因为要获得正确的结果，必须取决于事件的发生时序。

大多数竞态条件的本质——基于一种可能失效的观察结果来做出判断或者执行某个计算。然而事实上，在观察到这个结果以及开始做出判断或执行计算时，观察结果可能会变得无效。

#### 2.2.2 示例：延迟初始化中的竞态条件

延迟初始化的目的是将对象初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。

竞态条件并不会总是产生错误，还需要某种不恰当的执行时序。

#### 2.2.3 复合操作

要避免竞态条件问题，就必须在某个线程修改该变量时，**通过某种方式防止其他线程使用这个变量**，从而确保其他线程**只能在修改操作完成之前或之后读取和修改状态**，而不是在修改状态的过程中。

在实际情况中，应**尽可能地使用现有的线程安全对象来管理类的状态**。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。

### 2.3 加锁机制

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

#### 2.3.1 内置锁

Java提供了一种内置的锁机制**同步代码块**（Synchronized Block）来支持原子性。

同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。

每个Java对象都可以用做一个实现同步的锁，这些锁被称为**内置锁**或**监视器**。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java的内置锁相当于一种**互斥体**（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远等待下去。

#### 2.3.2 重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。

但由于**内置锁可重入**，因此如果某个线程试图**获得一个已经由它自己持有的锁**，**那这个请求就会成功**。“重入”意味着获取锁的操作的粒度是“线程”而不是“调用”。

当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。计数值为0时，这个锁将被释放。

重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。

**可重入的锁**避免了这种情况死锁的发生

```java
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}
public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();
    }
}
```

### 2.4 用锁来保护状态

锁能使其保护的代码以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。

**访问共享状态的复合操作，必须是原子操作以避免产生竞态条件**。如果在复合操作的执行过程中持有一个锁，那么会使复合操作成为原子操作。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都要使用同一个锁。

**对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有一个锁，在这种情况下，我们称状态变量是由这个锁保护的**。

当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，知识为了免去显式地创建锁对象。

**每个共享的和可变的变量都应该只由一个锁来保护，从而使开发人员知道是哪一个锁。**

一种常见的加锁约定是，**将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码进行同步**，使得该对象上不会发生并发访问。

当类的不变性条件涉及多个状态变量时，在不变性天剑中的每个变量都必须由同一个锁保护。

**对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由一个锁来保护**。

如果不加区别地滥用synchronized，可能导致程序中出现过多的同步。

虽然synchronized方法可以确保单个操作的原子性，但如果要**把多个操作合并为一个复合操作，还是需要额外的加锁机制**。此外，每个方法都作为同步方法还可能导致活跃性问题或性能问题。

### 2.5 活跃性与性能

要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须得到满足）、简单性和性能。

**通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）**。

使用锁时，要清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。

**当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁**。

## 第3章 对象的共享

关键字synchronized不仅能用于实现原子性或者确定“临界区”，还有另一个重要方面：内存可见性（Memory Visibility）。即不仅**要防止某个线程正在使用对象状态而另一个线程在同时修改该状态**，而且要**确保当一个线程修改了对象状态后，其他线程要能够看到发生的状态变化**。

### 3.1 可见性

通常无法确保执行读操作的线程能适时地看到其他线程写入的值。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

在没有同步的情况下，**编译器、处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整**。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

#### 3.1.1 失效数据

除非每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：**一个线程可能获得某个变量的最新值，而获得另一个变量的失效值**。

#### 3.1.2 非原子的64位操作

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证被称为**最低安全性**。

最低安全性适用于绝大多数变量，但存在例外：**非volatile类型的64位数值变量**。

Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，**JVM允许将64为的读操作或写操作分解为两个32位操作**。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，**在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的**，除非用关键字volatile来声明它们，或者用锁保护起来。

#### 3.1.3 加锁与可见性

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。即当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在**锁被释放之前，A看到的变量值在B获得锁后同样可以由B看到**。

在访问某个共享且可变的变量时，要求所有线程在同一个锁上同步，是为了确保某个线程写入该变量对于其他线程来说都是可见的。

**加锁的含义不仅仅局限于互斥行为，还包括内存可见性**。为了确保所有线程都能看到共享变量最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

#### 3.1.4 Volatile变量

Java提供了volatile变量来确保变量的更新操作通知到了其他线程。

当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量时共享的，因此不会将该变量上的操作与其他内存操作一起重排序，volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方。

访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。

从内存可见性的角度看，**写入**volatile变量相当于**退出同步代码块**，而**读取**volatile变量相当于**进入同步代码块**。

在代码中依赖volatile变量来控制可见性，通常比使用锁的代码更脆弱，也更难以理解。

**仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们**。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。**volatile变量的正确使用方式：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期时间的发生**（例如，初始化或关闭）。

volatile变量的一种典型用法

```java
volatile boolean asleep;
...
    while (!asleep)
        countSomeSheep();
```

volatile变量**通常用做某个操作完成、发生中断或状态的标志**。volatile的语义不足以确保递增操作(count++)的原子性，除非能确保只有一个线程对变量执行写操作。

**加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。**

当且仅当满足以下所有条件时，才应该使用volatile变量：

* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单线程更新变量的值
* 该变量不会与其他状态变量一起纳入不变性条件中
* 在访问变量时不需要加锁

### 3.2 发布与逸出

“发布”一个对象是指，使对象能够在当前作用域之外的代码中使用。例如将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个**非私有的方法中返回该引用**。

将对象的引用保存到一个公有的静态变量中

```java
public static Set<Secret> knownSecrets;
public void initialize() {
    knowSecrets = new HashSet<Secret>();
}
```

从非私有方法中返回一个引用

```java
class UnsafeStates {
    private String[] states = new String[] {
        "AK", "AL", ...
    };
    public String[] getStates() { return states; }
}
```

states这个变量逸出了作用域。

当发布某个对象时，可能会间接地发布其他对象。

当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。

无论其他线程会对已发布的引用执行何种操作，**误用该引用的风险都始终存在**。某个对象**逸出后**，必须假设有某个类或线程可能会误用该对象。这正是需要**封装**的主要原因：封装能够使对程序的**正确性进行分析变得可能**，并使得无意中**破坏约束条件变得更难**。

发布一个内部的类实例也是一种发布对象或内部状态的机制。这里的内部类会自动持有外部类的引用，使得ThisEscape在没有被构造完成的情况下就逸出了this指针

```java
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            });
    }
}
```

#### 安全的对象构造过程

如果this引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。

**一个常见的错误：在构造函数中启动一个线程。**

当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。即**在对象尚未完全构造之前，新的线程就可以看见它**。

在构造函数中可以创建线程，但不要立即启动线程，而是通过一个start或initialize方法启动。

用**工厂方法**来防止this引用在构造过程中逸出

```java
public class SafeListener {
    private final EvenListener listener;
    private SafeListener() {
        public void onEvent(Event e) {
            doSomething(e);
        }
    }
    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
```

### 3.3 线程封闭

当某个对象**封闭在一个线程中**时，这种用法将**自动实现线程安全性**，及时被封闭的对象本身不是线程安全的。

Java语言及其核心库提供了一些机制来帮助维持线程封闭性，如局部变量和ThreadLocal类，但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。

#### 3.3.1 Ad-hoc线程封闭

Ad-hoc线程封闭指维护线程封闭性的职责完全由程序实现来承担。

这种方式非常脆弱，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。

在程序上尽量少用，可能的情况下尽量采用更强的线程封闭技术（栈封闭或ThreadLocal类）。

#### 3.3.2 栈封闭

栈封闭是线程封闭的一种特例，在栈封闭中，只有**通过局部变量才能访问对象**。

**局部变量的固有属性之一就是封闭在执行线程中**。它们位于执行线程的栈中，其他线程无法访问这个栈。

栈封闭比Ad-hoc线程封闭更易于维护，也更加健壮。

```java
public int loadTheArk(Collection<Animal> candidates) {
    SortedSet<Animal> animals;
    int numPairs = 0;
    Animal candidate = null;
    
    // animals被封闭在方法中，不要使它们溢出
    animals = new TreeSet<Animal>(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for (Animal a : animals) {
        if (candidate == null || candidate.isPotentialMate(a))
            candidate = a;
        else {
            ark.load(new AnimalPair(candidate, a));
            ++numPairs;
            candidate = null;
        }
    }
    return numPairs;
}
```

animals引用指向集合animals，这个引用被封闭在局部变量中，因此也被封闭在执行线程中。

在线程的上下文使用类似的非线程安全的对象，该对象仍然是线程安全的。

#### 3.3.3 ThreadLocal类

维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。

ThreadLocal提供了get与set等访问接口或方法，这些方法**为每个使用该变量的线程都存有一份独立的副本**，因此get总是**返回由当前执行线程在调用set时设置的最新值**。

ThreadLocal对象通常用于防止对可变的单实例（Singleton）或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个而方法都要传递一个Connection对象

```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
  	public Connection initialValue() {
        return DriverManager.getConnection(DB_URL);
    };
}
public static Connection getConnection() {
    return connectionHolder.get();
}
```

### 3.4 不变性

如果某个对象在**被创建后其状态就不能被修改**，那么这个对象那个就称为**不可变对象**。

线程安全性是不可变对象的固有属性之一，它们的**不变性条件是由构造函数创建的**，只要它们的状态不改变，这些不变性条件就能得以维持。

**不可变对象一定是线程安全的。**

不可变性**并不等于将对象中所有的域都声明为final类型**，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为**在final类型的域中可以保存对可变对象的引用**。

当满足以下条件时，对象才是不可变的

* 对象创建以后其状态不能修改
* 对象的所有域都是final类型
* 对象是正确创建的（在对象创建期间，this引用没有逸出）

在不可变对象的内部仍可以使用可变对象来管理它们的状态

```java
public final class ThreeStorages {
  	private final Set<String> storages = new HashSet<String>();
  	
  	public ThreeStorages() {
    		storages.add("Moe");
      	storages.add("Larry");
      	storages.add("Curly");
	  }
  
  public boolean isStorage(String name) {
    	return storages.contains(name);
  }
}
```

#### 3.4.1 Final域

final类型的域是**不能修改**的(但**如果fianl域所引用的对象是可变的，那么这些被引用的对象是可以修改的**)。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

即使对象可变，通过将对象的某些域声明为final类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。

"**除非需要某个域是可变的，否则应将其声明为final域**"，是一个良好的编程习惯。

#### 3.4.2 使用volatile类型来发布不可变对象

用**volatile类型和不可变对象**可以提供一种弱形式的原子性。

对于在访问和更新多个相关变量时出现的竞态条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。如果是一个**可变的对象**，那么就**必须使用锁来确保原子性**。如果是一个不可变对象，那么当线程获得了该对象的引用后，就不用担心另一个线程会修改对象的状态。如果要更新这些变量，那么可以**创建一个新的容器对象**，但其他使用原有对象的线程仍然会看到对象处于一致的状态。

通过**使用包含多个状态变量的容器对象来维持不变性条件**，并使用一个volatile类型的引用来确保可见性。

### 3.5 安全发布

某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。

#### 3.5.1 不正确发布：正确的对象被破坏

不能指望一个尚未被完全创建的对象拥有完整性。观察该对象的线程将看到对象处于不一致状态，看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。

```java
public class Holder {
    private int n;
    public Holder(int n) {this.n = n; }
    
    public void assertSanity() {
        if (n != n)
            throw new AssertionError("This statement is false.");
    }
}
```

**没有使用同步来确保Holder对象对其他线程可见**，因此将Holder称为"未被正确发布"。

存在两个问题。

首先，除发布对象的线程外，**其他线程可以看到Holder域是一个失效值**，因此将看到一个空引用或者之前的旧值。

然而，更糟糕的情况是，线程看到Holder引用的值是最新的，但Holder状态的值却是失效的。

更不可预测，在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值，这也是assertSainty抛出AssertionError的原因。

#### 3.5.2 不可变对象与初始化安全性

不可变对象是一种非常重要的对象，**Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证**。即使**某个对象的引用对其他线程是可见**的，也**并不意味着对象状态对于使用该对象的线程来说一定可见**。为了确保对象状态能呈现出一致的视图，就必须使用同步。

即使在发布不可变对象的引用时**没有用同步**，也**仍然可以安全地访问该对象**。为了维持这种初始化安全性的保证，必须**满足不可变性**的所有需求：**状态不可修改，所有域都是final类型，以及正确的构造过程**。

**任何线程都可以在不需要额外同步的情况下同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。**

这种保证还将延伸到被正确创建对象中所有final类型的域。在没有额外同步的情况下，也可以安全地访问final类型的域。但如果final域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。

#### 3.5.3 安全发布的常用模式

可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时必须使用同步。

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

* 在静态初始化函数中初始化一个对象引用
* 将对象的引用保存到volatile类型的域或AtomReference对象中
* 将对象的引用保存到某个正确构造对象的final类型域中
* 将对象的引用保存到一个由锁保护的域中

在线程安全容器内部同步意味着，在讲对象放入到某个容器中，如Vector或synchronizedList时，将满足最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便这段读/写X的应用程序代码中没有包含显式的同步。

线程安全库中的容器类提供了以下的安全发布保证

* 通过将**一个键或者值**放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程
* 通过将**某个元素**放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、sychronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程
* 通过将**某个元素**放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程

通常，要**发布一个静态构造的对象**，最简单和最安全的方式是使用**静态的初始化器**：

```java
public static Holder holder = new Holder(42);
```

**静态初始化器由JVM在类的初始化阶段执行**。由于在**JVM内部存在着同步机制**，因此通过这种方式初始化的任何对象都可以被安全地发布。

#### 3.5.4 事实不可变对象

如果对象在发布后不会被修改，那么对于其他没有额外同步情况下安全地访问这些对象的线程来说，安全发布是足够的。

如果对象**从技术上来看是可变的**，但其状态**在发布后不会再改变**，那么把这种对象称为"事实不可变对象"。

通过使用事实不可变对象，可以**简化开发过程**，而且还能由于**减少了同步而提高性能**。

**在没有额外的同步情况下，任何线程都可以安全地使用被安全发布的事实不可变对象**。

#### 3.5.5 可变对象

如果对象在**构造后可以修改**，那么**安全发布只能确保"发布当时"状态的可见性**。

对于**可变对象**，不仅在发布对象时需要使用同步，而且在每次对象**访问时同样需要使用同步**来确保后续修改操作的可见性。

要安全地共享可变对象，**这些对象就必须被安全地发布**，并且必须是线程安全的或由某个锁保护起来。

对象的发布需求取决于它的可变性：

* 不可变对象可以通过任意机制来发布
* 事实不可变对象必须通过安全方式来发布
* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来

#### 3.5.6 安全地共享对象

发布一个对象时，必须明确说明对象的访问方式。

在并发程序和共享对象时，可以使用一些使用的策略：

* **线程封闭**：线程封闭的对象只能由一个线程持有，对象被封闭在该线程中，并且只能由这个线程修改。
* **只读共享**：在没有额外同步的情况下，**共享的只读对象**可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括**不可见对象**和**事实不可变对象**。
* **线程安全共享**：线程安全的对象在其**内部实现同步**，因此多个线程可以**通过对象的公有接口**来进行访问而不需要进一步同步。
* **保护对象**：被保护的对象**只能通过持有特定的锁来访问**。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由**某个特定锁保护的对象**。

