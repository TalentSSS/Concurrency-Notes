## 第2章 线程安全性

在构建稳健的并发程序时，必须正确地使用**线程**和**锁**。要编写线程安全的代码，核心在于要对状态访问进行管理，特别是对**共享**的（Shared）和**可变**的（Mutable）状态的访问。

“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

* 不在线程之间共享该状态变量
* 将状态变量修改为不可变的变量
* 在访问状态变量时使用同步

当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不可变性规范都能起到一定的帮助作用。

### 2.1 什么是线程安全性

线程安全的定义中，最核心的概念就是**正确性**。

正确性的含义是：某个类的**行为**与其**规范**完全**一致**。

**线程安全性**：当多个线程访问某个类时，**不管运行时环境采用何种调度方式**或者**这些线程将如何交替执行**，并且在**主调代码中不需要任何额外的同步或协同**，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

**无状态的对象一定是线程安全的**。

### 2.2. 原子性

#### 2.2.1 竞态条件

因为要获得正确的结果，必须取决于事件的发生时序。

大多数竞态条件的本质——基于一种可能失效的观察结果来做出判断或者执行某个计算。然而事实上，在观察到这个结果以及开始做出判断或执行计算时，观察结果可能会变得无效。

#### 2.2.2 示例：延迟初始化中的竞态条件

延迟初始化的目的是将对象初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。

竞态条件并不会总是产生错误，还需要某种不恰当的执行时序。

#### 2.2.3 复合操作

要避免竞态条件问题，就必须在某个线程修改该变量时，**通过某种方式防止其他线程使用这个变量**，从而确保其他线程**只能在修改操作完成之前或之后读取和修改状态**，而不是在修改状态的过程中。

在实际情况中，应**尽可能地使用现有的线程安全对象来管理类的状态**。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。

### 2.3 加锁机制

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

#### 2.3.1 内置锁

Java提供了一种内置的锁机制**同步代码块**（Synchronized Block）来支持原子性。

同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。

每个Java对象都可以用做一个实现同步的锁，这些锁被称为**内置锁**或**监视器**。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java的内置锁相当于一种**互斥体**（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远等待下去。

#### 2.3.2 重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。

但由于**内置锁可重入**，因此如果某个线程试图**获得一个已经由它自己持有的锁**，**那这个请求就会成功**。“重入”意味着获取锁的操作的粒度是“线程”而不是“调用”。

当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。计数值为0时，这个锁将被释放。

重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。

**可重入的锁**避免了这种情况死锁的发生

```java
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}
public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();
    }
}
```

### 2.4 用锁来保护状态

锁能使其保护的代码以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。

**访问共享状态的复合操作，必须是原子操作以避免产生竞态条件**。如果在复合操作的执行过程中持有一个锁，那么会使复合操作成为原子操作。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都要使用同一个锁。

**对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有一个锁，在这种情况下，我们称状态变量是由这个锁保护的**。

当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，知识为了免去显式地创建锁对象。

**每个共享的和可变的变量都应该只由一个锁来保护，从而使开发人员知道是哪一个锁。**

一种常见的加锁约定是，**将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码进行同步**，使得该对象上不会发生并发访问。

当类的不变性条件涉及多个状态变量时，在不变性天剑中的每个变量都必须由同一个锁保护。

**对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由一个锁来保护**。

如果不加区别地滥用synchronized，可能导致程序中出现过多的同步。

虽然synchronized方法可以确保单个操作的原子性，但如果要**把多个操作合并为一个复合操作，还是需要额外的加锁机制**。此外，每个方法都作为同步方法还可能导致活跃性问题或性能问题。

### 2.5 活跃性与性能

要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须得到满足）、简单性和性能。

**通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）**。

使用锁时，要清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。

**当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁**。
